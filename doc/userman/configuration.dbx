<?xml version="1.0" encoding='UTF-8'?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook V4.2//EN"
    "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<sect1 id="configuration">
  <title>Configuring Libtabula</title>

  <para>The default configuration of libtabula is suitable for most
  purposes, but there are a few things you can change to make it meet
  special needs.</para>

  <sect2 id="mysql-loc">
    <title>The Location of the C API Development Files</title>

    <para>Libtabula can be built against several C DBMS
    APIs such as <filename>libsqlite3</filename> and <ulink
    url="https://dev.mysql.com/downloads/connector/c/">Connector/C</ulink>.
    The library build process tries to find these automattically,
    but sometimes it needs guidance, particularly when you install
    these files somewhere nonstandard. I&#x2019;ts a particular problem
    on Windows, where installation directories are often versioned,
    so each release of libtabula just has to guess at a few version
    numbers common at the time of release.</para>

    <para>On platforms that use Autoconf<footnote><para>Linux,
    Solaris, the BSDs, Mac OS X command line (as opposed to the
    Xcode IDE), Cygwin... Basically, Unix or anything that works
    like it.</para></footnote>, the <filename>configure</filename>
    script can usually figure out the location of the C API
    development files by itself<footnote><para>I don&#x2019;t say
    &#x201C;Connector/C&#x201D; here because the name change generally
    hasn&#x2019;t percolated out to Unixy systems. It&#x2019;s more
    commonly used on Windows systems, since the separate Connector/C
    download lets them avoid installing a MySQL server just to get
    development headers and libraries.</para></footnote> It simply
    tries a bunch of common installation locations until it finds one
    that works. If your MySQL server was installed in a nonstandard
    location, you will have to tell the <filename>configure</filename>
    script where these files are with some combination
    of the <computeroutput>--with-mysql</computeroutput>,
    <computeroutput>--with-mysql-include</computeroutput>, and
    <computeroutput>--with-mysql-lib</computeroutput> flags. See
    <filename>README-Unix.txt</filename> for details.</para>

    <para>If you need to modify the build system files, per-platform
    instructions are in
    <filename>README-Visual-Studio.txt</filename>,
    <filename>README-MinGW.txt</filename>, and
    <filename>README-Mac-OS-X.txt</filename>.</para>
  </sect2>


  <sect2 id="max-fields">
    <title>The Maximum Number of Fields Allowed</title>

    <para>Libtabula offers two ways to automatically build
    SQL queries at run time: <xref linkend="tquery"/> and <link
    linkend="ssqls">SSQLS</link>. There&#x2019;s a limit on the number
    of fields these mechanisms support, defaulting to 25 fields in the
    official libtabula packages.<footnote><para>If you&#x2019;re using
    a third-party libtabula package, its maintainer may have increased
    these field counts so the resulting headers more closely approach
    the size limit of the compiler the package was built with. In that
    case, you can look at the top of each generated header file to
    find out how many fields each supports.</para></footnote> The files
    embodying these limits are <filename>lib/querydef.h</filename> and
    <filename>lib/ssqls.h</filename>, each generated by Perl scripts of
    the same name but with a <filename>.pl</filename> extension.</para>

    <para>The default <filename>querydef.h</filename> is small and
    its size only increases linearly with respect to maximum field
    count.</para>

    <para><filename>ssqls.h</filename> is a totally
    different story. The default 25 field limit
    makes <filename>ssqls.pl</filename> generate an
    <filename>ssqls.h</filename> over 1&nbsp;MB. Worse,
    the field limit to file size relation is
    <emphasis>quadratic</emphasis>.<footnote><para>The file
    size equation, for you amateur mathematicians out there,
    is <phrase role="math">N<subscript>lines</subscript> =
    18.5f<superscript>2</superscript> + 454.5f + 196.4</phrase>,
    where <varname>f</varname> is the field count.</para></footnote>
    This has a number of bad effects:</para>

    <itemizedlist>
      <listitem>
        <para>Generating header files to support more fields than
        you actually require is a waste of space and bandwidth.</para>
      </listitem>

      <listitem>
        <para>Some compilers have arbitrary limits on the size of
        macros they&#x2019;re able to parse. Exceeding these limits
        usually causes the compiler to misbehave badly, rather than
        fail gracefully.</para>
      </listitem>

      <listitem>
        <para>Because it increases the size of two key files used
        in building libtabula itself and programs built on it, it
        increases compile times significantly. One test I did here
        showed a tripling of compile time from quadrupling the field
        limit.</para>
      </listitem>

      <listitem>
        <para>More than 25 fields in a table is a good sign of a bad
        database design, most likely a denormalization problem.</para>
      </listitem>
    </itemizedlist>

    <para>The default limits try to mitigate against all of these
    factors while still being high enough to be useful with most
    DB designs.</para>

    <para>If you&#x2019;re building libtabula from source on a platform
    that uses Autoconf, the easiest way to change these limits is at
    configuration time:</para>

    <screen>
./configure --with-field-limit=50</screen>

    <para>That causes the configuration script to pass the
    <command>-f</command> flag to the two Perl scripts named above,
    overriding the default of 25 fields. Obviously you need a
    Perl interpreter on the system for this to work, but Perl is
    usually installed by default on systems libtabula supports via
    Autoconf.</para>

    <para>On all other platforms, you&#x2019;ll have to give the
    <command>-f</command> flag to these scripts yourself. This
    may require installing Perl and putting it in the command path
    first. Having done that, you can do something like this to raise
    the limits:</para>

    <screen>
cd lib
perl ssqls.pl -f 50
perl querydef.pl -f 50</screen>

    <para>Note the need to run these commands within the
    <filename>src</filename> subdirectory of the libtabula source
    tree. (This is done for you automatically on systems where you
    are able to use the Autoconf method.)</para>
  </sect2>


  <sect2 id="buried-headers">
    <title>Buried MySQL C API Headers</title>

    <para>It&#x2019;s common these days on Unixy systems to install
    the MySQL C API headers in a <filename>mysql</filename> directory
    under some common <filename>include</filename> directory. If the
    C API headers are in <filename>/usr/include/mysql</filename>, we
    say they are &#x201C;buried&#x201D; underneath the system&#x2019;s
    main include directory, <filename>/usr/include</filename>. Since
    the libtabula headers depend on these C API headers, it can be
    useful for libtabula to know this fact.</para>

    <para>When libtabula includes one of the C API headers, it normally
    does so in the obvious way:</para>

    <programlisting>
#include &lt;mysql.h&gt;
</programlisting>

    <para>But, if you define the
    <varname>LIBTABULA_MYSQL_HEADERS_BURIED</varname> macro, it
    switches to this style:</para>

    <programlisting>
#include &lt;mysql/mysql.h&gt;
</programlisting>

    <para>In common situations like the
    <filename>/usr/include/mysql</filename> one, this simplifies the
    include path options you pass to your compiler.</para>
  </sect2>


  <sect2 id="c99">
    <title>Building on Systems Without Complete C99 Support</title>

    <para>Libtabula uses the <ulink
    url="http://en.wikipedia.org/wiki/C_(programming_language)#C99">C99</ulink>
    header <filename>stdint.h</filename> for portable fixed-size
    integer typedefs where possible. The C99 extensions
    aren&#x2019;t yet officially part of the C++ Standard, so
    there are still some C++ compilers that don&#x2019;t offer this
    header. Libtabula works around the lack of this header where it
    knows it needs to, but your platform might not be recognized,
    causing the build to break. If this happens, you can define the
    <varname>LIBTABULA_NO_STDINT_H</varname> macro to make libtabula
    use its best guess for suitable integer types instead of relying
    on <filename>stdint.h</filename>.</para>

    <para>Libtabula also uses C99&#x2019;s <type>long long</type>
    data type where available. Libtabula has workarounds for platforms
    where this is known not to be available, but if you get errors
    in <filename>common.h</filename> about this type, you can define
    the macro <varname>LIBTABULA_NO_LONG_LONGS</varname> to make
    libtabula fall back to portable constructs.</para>
  </sect2>
</sect1>
